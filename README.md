# SecKill
秒杀相关文档，源码
秒杀
电商网站的秒杀

技术架构
SpringBoot + Redis + RabbitMQ

原理
秒杀与其他业务最大的区别在于：秒杀的瞬间，（1）系统的并发量会非常的大（2）并发量大的同时，网络的流量也会瞬间变大。

关于（2），最常用的办法就是做页面静态化，也就是常说的前后端分离，把静态页面直接缓存到用户的浏览器端，所需要的数据从服务端接口动态获取。这样会大大节省网络的流量，再加上CDN，一般不会有大问题。

关于（1），这里的核心问题就在于如何在大并发的情况下能保证DB能扛得住压力，因为大并发的瓶颈在于DB。如果说请求直接从前端透传到DB，显然，DB是无法承受几十万上百万甚至上千万的并发量的。所以，我们能做的只能是减少对DB的访问，前端发出了100万个请求，通过我们的处理，最终只有10个会访问DB，这样就可以了！针对秒杀这种场景，因为秒杀商品的数量是有限的，这种做法刚好适用！

那么具体是如何来减少DB的访问呢？

假如：某个商品可秒杀的数量是10，那么在秒杀活动开始之前，把商品的ID和数量加载到缓存，比如：Redis。服务端收到请求的时候，首先减一下Redis里面的数量，如果数量减到0随后的访问直接返回秒杀失败。也就是说，只有10个请求最终会去实际的请求DB。

当然，如果我们的商品数比较多，1万件商品参与秒杀，1万*10=10万个并发去请求DB，DB的压力还是会很大，这里就用到另一个非常重要的组件：消息队列。我们不是把请求直接去访问DB，而是先把请求写到消息队列，做一个缓存，然后再去慢慢的更新数据库。这样做以后，前端用户的请求可能不会立即得到响应是成功还是失败，很可能得到的是一个排队中的返回值，这个时候，需要客户端再去服务端轮询，因为我们不能保证一定就秒杀成功了。当服务端出队，生成订单以后，把用户ID和商品ID写到缓存中，来应对客户端的轮询就可以了。

这样处理以后，我们的应用是可以很简单的进行分布式横向扩展的，以应对更大的并发。

当然，秒杀系统还有很多要处理的事情：比如防刷限流、比如分布式Session等等。


# 方案二
首先业务分离（就是把秒杀服务器与网站其他服务器完全隔离，以防流量过大带着其他服务一起死，要死你就死吧，把配置高的服务器都用来秒杀）,最前端的页面要被CDN或反向代理是肯定的，之后限流（比如服务器只能承受10W流量，高于10W的请求直接返回失败），降级（秒杀页面并发高到一定程度时可以断开某些接口查询，如推荐，相似物品，历史价格等等，减少服务器返回时间），熔断（某些接口大于某个流量活并发峰值直接返回失败,或者返回默认数据如：某些产品一直有货 ），然后进入到负载均衡器中，负载均衡器分配到web服务器中，web服务器在进入队列，之后进入一个统一的缓存计数器中，秒杀结束后，通过秒杀日志,worker计算剩余库存(此处为异步处理)，并且使用ＭＱ推送下单信息至各个系统（订单，库存，发货，子业务域。。。等等系统），各个系统处理后写入数据库。这么大流量的系统想要保证数据库中与前台库存与缓存的一致性几乎不可能，但是我们只要保证最终落表的数据是正确的就行,如同上文中使用worker读取日志采用异步的方式进行数据落表处理(当然方法还有很多，这里只介绍一个典型方案)，这就是传说中的弱一致性保持，分布式系统CAP中通常都会牺牲掉C

作者：黄辉冯
链接：https://www.zhihu.com/question/20978066/answer/56149380
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
